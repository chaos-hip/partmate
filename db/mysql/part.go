package mysql

import (
	"fmt"

	"git.chaos-hip.de/RepairCafe/PartMATE/models"
)

const (
	partTableName = "Part"
)

var (
	// Search query for the parts search
	querySearchPart = fmt.Sprintf(`SELECT
		parts.id AS id,
		parts.category_id AS category_id,
		parts.name AS name,
		parts.description AS description,
		parts.comment AS comment,
		parts.stockLevel AS stockLevel,
		parts.minStockLevel AS minStockLevel,
		parts.status AS status,
		parts.storageLocation_id AS storageLocation_id,
		parts.needsReview AS needsReview,
		parts.partCondition AS partCondition,
		parts.lowStock AS lowStock,
		links.link AS link,
		attachments.id AS image_id,
		att_links.link AS image_link
	FROM
		%s AS parts
	LEFT OUTER JOIN
		%s AS links
	ON
		links.link = (SELECT link FROM %s AS l2 WHERE l2.partID = parts.id ORDER BY l2.auto_generated LIMIT 1)
	LEFT OUTER JOIN
		%s AS attachments
	ON
		attachments.id = (SELECT id FROM %s AS a2 WHERE a2.part_id = parts.id AND a2.mimetype IN ('image/jpeg', 'image/png') ORDER BY a2.created ASC LIMIT 1)
	LEFT OUTER JOIN
		%s AS att_links
	ON
		att_links.link = (SELECT link FROM %s AS l3 WHERE l3.partAttachmentID = attachments.id ORDER BY l3.auto_generated LIMIT 1)
	WHERE
		parts.name LIKE ? OR
		parts.description LIKE ?
	ORDER BY
		parts.name
	LIMIT ?
	OFFSET ?`,
		partTableName,
		linkTableName,
		linkTableName,
		partAttachmentTableName,
		partAttachmentTableName,
		linkTableName,
		linkTableName,
	)
)

// GetPartByLink returns the part belonging to the link given
func (d *DB) GetPartByLink(id string) (*models.Part, error) {
	return nil, fmt.Errorf("not implemented \u200d")
}

// SearchParts searches for the parts matching the given search query and returns a list of them
// ordered by name
func (d *DB) SearchParts(search models.Search) ([]models.Part, error) {
	res := []*models.Part{}
	term := fmt.Sprintf("%%%s%%", search.Term)
	if search.Limit > maximumPageSize {
		search.Limit = maximumPageSize
	}
	if search.Limit == 0 {
		search.Limit = defaultPageSize
	}
	if err := d.db.Select(&res, querySearchPart, term, term, search.Limit, search.Offset); err != nil {
		return nil, fmt.Errorf("failed to search parts: %w", err)
	}
	if len(res) == 0 {
		return []models.Part{}, nil
	}
	storageMap := map[int][]*models.Part{}
	// Create links for all the parts that have none - and images that have none
	for _, p := range res {
		// Part link
		if !p.Link.Valid {
			l, err := d.CreateLink(models.Link{PartID: &p.ID, AutoGenerated: true})
			if err != nil {
				return nil, fmt.Errorf("failed to create link for part %d: %w", p.ID, err)
			}
			p.Link.String = l.Link
			p.Link.Valid = true
		}
		if p.ImageID.Valid && !p.ImageLink.Valid {
			imgID := int(p.ImageID.Int64)
			l, err := d.CreateLink(models.Link{PartAttachmentID: &imgID, AutoGenerated: true})
			if err != nil {
				return nil, fmt.Errorf("failed to create link for image %d: %w", imgID, err)
			}
			p.ImageLink.String = l.Link
			p.ImageLink.Valid = true
		}
		if _, ok := storageMap[p.StorageLocationID]; !ok {
			storageMap[p.StorageLocationID] = []*models.Part{}
		}
		storageMap[p.StorageLocationID] = append(storageMap[p.StorageLocationID], p)
	}
	// Add the storage locations
	var ids []int
	for k := range storageMap {
		ids = append(ids, k)
	}
	locations, err := d.getStorageLocationsByIDs(ids)
	if err != nil {
		return nil, fmt.Errorf("failed to retrieve storage location info: %w", err)
	}
	for _, loc := range locations {
		for _, part := range storageMap[loc.ID] {
			cpy := loc // Do a copy of the location to not map the counter var
			part.Storage = &cpy
		}
	}
	// Repack the parts
	out := []models.Part{}
	for _, p := range res {
		out = append(out, *p)
	}
	return out, nil
}

// AddPartStock adds one or more instances to the amount of parts present of the selected part type
func (d *DB) AddPartStock(id, price, comment string, amount uint) error {
	return fmt.Errorf("not implemented")
}

// RemovePartStock removes one or more parts of the selected part type from the inventory
func (d *DB) RemovePartStock(id, comment string, amount uint) error {
	return fmt.Errorf("not implemented")
}
