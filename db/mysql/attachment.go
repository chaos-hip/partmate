package mysql

import (
	"database/sql"
	"fmt"

	"github.com/chaos-hip/partmate/models"
)

const (
	partAttachmentTableName = "PartAttachment"
)

var (
	queryGetAttachmentByLink = fmt.Sprintf(`SELECT
		links.link AS link,
		attachments.id AS id,
		attachments.part_id AS part_id,
		attachments.type AS type,
		attachments.filename AS filename,
		attachments.originalname AS originalname,
		attachments.mimetype AS mimetype,
		attachments.size AS size,
		attachments.extension AS extension,
		attachments.description AS description,
		attachments.isImage AS isImage
	FROM
		%s AS links
	LEFT OUTER JOIN
		%s AS attachments
	ON
		attachments.id = links.partAttachmentID
	WHERE
		links.link = ?
	AND
		attachments.id IS NOT NULL`,
		linkTableName,
		partAttachmentTableName,
	)

	queryGetAttachmentsByPartLink = fmt.Sprintf(`SELECT
		att_links.link AS link,
		att.id AS id,
		att.part_id AS part_id,
		att.type AS type,
		att.filename AS filename,
		att.originalname AS originalname,
		att.mimetype AS mimetype,
		att.size AS size,
		att.extension AS extension,
		att.description AS description,
		att.isImage AS isImage
	FROM
		%s AS links
	LEFT OUTER JOIN
		%s AS att
	ON
		att.part_id = links.partID
	LEFT OUTER JOIN
		%s AS att_links
	ON
		att_links.link = (SELECT link FROM %s AS l2 WHERE l2.partAttachmentID = att.id ORDER BY l2.auto_generated LIMIT 1)
	WHERE
		links.link = ?
	AND
		links.partID IS NOT NULL
	ORDER BY
		att.mimetype ASC, originalname ASC`,
		linkTableName,
		partAttachmentTableName,
		linkTableName,
		linkTableName,
	)
)

func (d *DB) CreatePartAttachmentEntry(partID, filename, mimeType string) (*models.PartAttachment, error) {
	return nil, fmt.Errorf("not implemented")
}

func (d *DB) GetAttachmentEntry(id string) (*models.PartAttachment, error) {
	var res models.PartAttachment
	if err := d.db.Get(&res, queryGetAttachmentByLink, id); err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, fmt.Errorf("failed to retrieve attachment by ID: %w", err)
	}
	res.BaseDir = d.dataDir
	return &res, nil
}

// GetAttachmentsByPartLink returns a list of attachments belonging to the part identified with the given link
func (d *DB) GetAttachmentsByPartLink(partLink string) ([]models.PartAttachment, error) {
	data := []*models.PartAttachment{}
	if err := d.db.Select(&data, queryGetAttachmentsByPartLink, partLink); err != nil {
		if err == sql.ErrNoRows {
			return []models.PartAttachment{}, nil
		}
		return nil, fmt.Errorf("failed to retrieve part attachment list: %w", err)
	}
	// Repack and add base Dir
	out := []models.PartAttachment{}
	for _, att := range data {
		cpy := *att
		cpy.BaseDir = d.dataDir
		// Generate the link for this attachment if it has none
		if !cpy.Link.Valid {
			l, err := d.CreateLink(models.Link{PartAttachmentID: &cpy.InternalID, AutoGenerated: true})
			if err != nil {
				return nil, fmt.Errorf("failed to create link for part %d: %w", cpy.InternalID, err)
			}
			cpy.Link.String = l.Link
			cpy.Link.Valid = true
		}
		out = append(out, cpy)
	}
	return out, nil
}
