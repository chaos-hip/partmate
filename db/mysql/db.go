package mysql

import (
	"database/sql"
	"fmt"
	"strings"
	"text/template"

	"git.chaos-hip.de/RepairCafe/PartMATE/db"
	"git.chaos-hip.de/RepairCafe/PartMATE/models"
	_ "github.com/go-sql-driver/mysql"
	"github.com/golang-migrate/migrate/v4"
	migratedb "github.com/golang-migrate/migrate/v4/database/mysql"
	_ "github.com/golang-migrate/migrate/v4/source/file"
	"github.com/jmoiron/sqlx"
	"github.com/lithammer/shortuuid/v3"
	"github.com/sirupsen/logrus"
)

const (
	migrationTableName = "mate_migrations"

	userFields    = "name, password_hash, permissions"
	userTableName = "mate_users"

	linkFields    = "link, partID, partAttachmentID, storageID, auto_generated"
	linkTableName = "mate_links"

	partTableName = "Part"

	partAttachmentTableName = "PartAttachment"

	storageLocationTableName = "StorageLocation"
)

var (

	// Search query for the parts search
	querySearchPart = fmt.Sprintf(`SELECT
		parts.id AS id,
		parts.category_id AS category_id,
		parts.name AS name,
		parts.description AS description,
		parts.comment AS comment,
		parts.stockLevel AS stockLevel,
		parts.minStockLevel AS minStockLevel,
		parts.status AS status,
		parts.storageLocation_id AS storageLocation_id,
		parts.needsReview AS needsReview,
		parts.partCondition AS partCondition,
		parts.lowStock AS lowStock,
		links.link AS link,
		attachments.id AS image_id,
		att_links.link AS image_link
	FROM
		%s AS parts
	LEFT OUTER JOIN
		%s AS links
	ON
		links.link = (SELECT link FROM %s AS l2 WHERE l2.partID = parts.id ORDER BY l2.auto_generated LIMIT 1)
	LEFT OUTER JOIN
		%s AS attachments
	ON
		attachments.part_id = (SELECT id FROM %s AS a2 WHERE a2.part_id = parts.id AND a2.mimetype IN ('image/jpeg', 'image/png') ORDER BY a2.created ASC LIMIT 1)
	LEFT OUTER JOIN
		%s AS att_links
	ON
		att_links.link = (SELECT link FROM %s AS l3 WHERE l3.partAttachmentID = attachments.id ORDER BY l3.auto_generated LIMIT 1)
	WHERE
		parts.name LIKE ? OR
		parts.description LIKE ?
	ORDER BY
		parts.name`,
		partTableName,
		linkTableName,
		linkTableName,
		partAttachmentTableName,
		partAttachmentTableName,
		linkTableName,
		linkTableName,
	)

	queryGetStorageByIDs = fmt.Sprintf(`SELECT
		storage.id AS id,
		storage.name AS name,
		links.link AS link
	FROM
		%s AS storage
	LEFT OUTER JOIN
		%s AS links
	ON
		links.link = (SELECT link FROM %s AS l2 WHERE l2.storageID = storage.id ORDER BY l2.auto_generated LIMIT 1)
	WHERE
		storage.id IN (?);`,
		storageLocationTableName,
		linkTableName,
		linkTableName,
	)
)

type DB struct {
	db *sqlx.DB
}

// getStorageLocationsByIDs returns the locations matching the IDs given
func (d *DB) getStorageLocationsByIDs(ids []int) ([]models.StorageLocation, error) {
	// Remap the IDs
	var inputArgs []interface{}
	for _, id := range ids {
		inputArgs = append(inputArgs, id)
	}
	res := []*models.StorageLocation{}
	query, args, err := sqlx.In(queryGetStorageByIDs, inputArgs)
	if err != nil {
		return nil, fmt.Errorf("failed to spread IN query")
	}
	query = d.db.Rebind(query)
	if err := d.db.Select(&res, query, args...); err != nil {
		return nil, fmt.Errorf("failed to load storage locations: %w", err)
	}
	out := []models.StorageLocation{}
	// Create links for all the storage locations that have none
	for _, loc := range res {
		if !loc.Link.Valid {
			l, err := d.CreateLink(models.Link{StorageID: &loc.ID, AutoGenerated: true})
			if err != nil {
				return nil, fmt.Errorf("failed to create link for storage location %#v: %w", loc.Name, err)
			}
			loc.Link.String = l.Link
			loc.Link.Valid = true
		}
		out = append(out, *loc)
	}
	return out, nil
}

// GetPartByLink returns the part belonging to the link given
func (d *DB) GetPartByLink(id string) (*models.Part, error) {
	return nil, fmt.Errorf("not implemented \u200d")
}

// SearchParts searches for the parts matching the given search query and returns a list of them
// ordered by name
func (d *DB) SearchParts(search models.Search) ([]models.Part, error) {
	res := []*models.Part{}
	term := fmt.Sprintf("%%%s%%", search.Term)
	if err := d.db.Select(&res, querySearchPart, term, term); err != nil {
		return nil, fmt.Errorf("failed to search parts: %w", err)
	}
	storageMap := map[int][]*models.Part{}
	// Create links for all the parts that have none - and images that have none
	for _, p := range res {
		// Part link
		if !p.Link.Valid {
			l, err := d.CreateLink(models.Link{PartID: &p.ID, AutoGenerated: true})
			if err != nil {
				return nil, fmt.Errorf("failed to create link for part %d: %w", p.ID, err)
			}
			p.Link.String = l.Link
			p.Link.Valid = true
		}
		if p.ImageID.Valid && !p.ImageLink.Valid {
			imgID := int(p.ImageID.Int64)
			l, err := d.CreateLink(models.Link{PartAttachmentID: &imgID, AutoGenerated: true})
			if err != nil {
				return nil, fmt.Errorf("failed to create link for image %d: %w", imgID, err)
			}
			p.ImageLink.String = l.Link
			p.ImageLink.Valid = true
		}
		if _, ok := storageMap[p.StorageLocationID]; !ok {
			storageMap[p.StorageLocationID] = []*models.Part{}
		}
		storageMap[p.StorageLocationID] = append(storageMap[p.StorageLocationID], p)
	}
	// Add the storage locations
	var ids []int
	for k := range storageMap {
		ids = append(ids, k)
	}
	locations, err := d.getStorageLocationsByIDs(ids)
	if err != nil {
		return nil, fmt.Errorf("failed to retrieve storage location info: %w", err)
	}
	for _, loc := range locations {
		for _, part := range storageMap[loc.ID] {
			cpy := loc // Do a copy of the location to not map the counter var
			part.Storage = &cpy
		}
	}
	// Repack the parts
	out := []models.Part{}
	for _, p := range res {
		out = append(out, *p)
	}
	return out, nil
}

// CreateUser creates a new user in the database
func (d *DB) CreateUser(user models.User) error {
	if user.PasswordHash == "" {
		return fmt.Errorf("no password set for new user")
	}
	query := fmt.Sprintf("INSERT INTO %s(%s) VALUES(?, ?, ?)", userTableName, userFields)
	if _, err := d.db.Exec(query, user.Username, user.PasswordHash, user.RawPermissions); err != nil {
		return fmt.Errorf("failed to insert new user: %w", err)
	}
	return nil
}

// GetUserByName returns the user with the given username or nothing if the user does not exist
func (d *DB) GetUserByName(name string) (*models.User, error) {
	u := models.User{}
	// Name is case-insensitive here - so we're normalizing it to lowercase
	name = strings.ToLower(name)
	if err := d.db.Get(&u, fmt.Sprintf("SELECT %s FROM %s WHERE name = ?", userFields, userTableName), name); err != nil {
		if err == sql.ErrNoRows {
			// Nothing found
			return nil, nil
		}
		return nil, fmt.Errorf("failed to fetch user record: %w", err)
	}
	return &u, nil
}

// GetLinkByID returns the link with the given ID
// Mainly this is used internally to fetch the DB ID of entities
func (d *DB) GetLinkByID(id string) (*models.Link, error) {
	query := fmt.Sprintf("SELECT %s FROM %s WHERE link = ?", linkFields, linkTableName)
	var out models.Link
	if err := d.db.Get(&out, query, id); err != nil {
		if err == sql.ErrNoRows {
			// Nothing found
			return nil, nil
		}
		return nil, fmt.Errorf("failed to fetch link: %w", err)
	}
	return &out, nil
}

// DeleteLinkByID will delete the link with the given ID
func (d *DB) DeleteLinkByID(linkID string) error {
	query := fmt.Sprintf("DELETE FROM %s WHERE link = ?", linkTableName)
	res, err := d.db.Exec(query, linkID)
	if err != nil {
		return fmt.Errorf("failed to delete link %#v: %w", linkID, err)
	}
	rows, err := res.RowsAffected()
	if err != nil {
		return fmt.Errorf("failed to get rows affected by deletion: %w", err)
	}
	if rows == 0 {
		return db.ErrNothingDeleted
	}
	return nil
}

// itemIdCheck checks if an item with the given ID exists in the table
// If if exists, it will just return a NIL error
func (d *DB) itemIdCheck(id int, tableName string) error {
	query := fmt.Sprintf("SELECT COUNT(*) FROM %s WHERE id = ?", tableName)
	var num int
	if err := d.db.Get(&num, query, id); err != nil {
		return fmt.Errorf("failed to check for item existence on %#v: %w", tableName, err)
	}
	if num == 0 {
		return fmt.Errorf("the linked item does not exist (%#v)", tableName)
	}
	return nil
}

// CreateLink creates the link to the given target
// Passing a link with an empty ID will generate a new ID
func (d *DB) CreateLink(link models.Link) (*models.Link, error) {
	if link.Link == "" {
		link.Link = shortuuid.New()
	}
	if link.PartID != nil {
		if err := d.itemIdCheck(*link.PartID, partTableName); err != nil {
			return nil, err
		}
	}
	if link.PartAttachmentID != nil {
		if err := d.itemIdCheck(*link.PartAttachmentID, partAttachmentTableName); err != nil {
			return nil, err
		}
	}
	if link.StorageID != nil {
		if err := d.itemIdCheck(*link.StorageID, storageLocationTableName); err != nil {
			return nil, err
		}
	}

	query := fmt.Sprintf("INSERT INTO %s(%s) VALUES(?, ?, ?, ?, ?)", linkTableName, linkFields)
	if _, err := d.db.Exec(
		query,
		link.Link,
		link.PartID,
		link.PartAttachmentID,
		link.StorageID,
		link.AutoGenerated,
	); err != nil {
		return nil, fmt.Errorf("failed to create link: %w", err)
	}
	return &link, nil
}

func (d *DB) CreatePartAttachmentEntry(partID, filename, mimeType string) (*models.Attachment, error) {
	return nil, fmt.Errorf("not implemented \u200d")
}

func (d *DB) GetAttachmentEntry(id string) (*models.Attachment, error) {
	return nil, fmt.Errorf("not implemented \u200d")
}

func (d *DB) AddPartStock(id, price, comment string, amount uint) error {
	return fmt.Errorf("not implemented \u200d")
}

func (d *DB) RemovePartStock(id, comment string, amount uint) error {
	return fmt.Errorf("not implemented \u200d")
}

func (d *DB) Close() {
	d.db.Close()
}

func Migrate(db *sql.DB, source string) error {
	logrus.Info("Running database migrations...")
	drv, err := migratedb.WithInstance(
		db,
		&migratedb.Config{
			MigrationsTable: migrationTableName,
		},
	)
	if err != nil {
		return fmt.Errorf("failed to create migration driver instance: %w", err)
	}
	if source == "" {
		source = "file://dbmigrations"
	}
	migrator, err := migrate.NewWithDatabaseInstance(
		source,
		"mysql", drv,
	)
	if err != nil {
		return fmt.Errorf("failed to create database migrator: %w", err)
	}
	if err := migrator.Up(); err != nil && err != migrate.ErrNoChange {
		return err
	}
	logrus.Info("Migrations done")
	return nil
}

func NewDB(host, port, username, password, dbName, migrationSource string) (db.DB, error) {

	host = template.URLQueryEscaper(host)
	port = template.URLQueryEscaper(port)
	username = template.URLQueryEscaper(username)
	password = template.URLQueryEscaper(password)
	dbName = template.URLQueryEscaper(dbName)

	// Create migration connection
	// multiStatements enables batch processing
	sqlDB, err := sql.Open("mysql", fmt.Sprintf("%s:%s@tcp(%s:%s)/%s?multiStatements=true", username, password, host, port, dbName))
	if err != nil {
		return nil, fmt.Errorf("failed to connect to database for migration: %w", err)
	}
	defer sqlDB.Close()
	if err := Migrate(sqlDB, migrationSource); err != nil {
		return nil, fmt.Errorf("failed to migrate database: %w", err)
	}

	sqlxDB, err := sqlx.Connect("mysql", fmt.Sprintf("%s:%s@tcp(%s:%s)/%s?parseTime=true", username, password, host, port, dbName))
	if err != nil {
		return nil, fmt.Errorf("failed to connect to database: %w", err)
	}

	return NewDBWithConnection(sqlxDB), nil
}

func NewDBWithConnection(conn *sqlx.DB) db.DB {
	return &DB{
		db: conn,
	}
}
