package models

import (
	"fmt"
	"strings"
	"time"
)

const (
	// TargetTypePart is the target type identifier for linking to parts
	TargetTypePart            = "part"
	TargetTypePartCategory    = "part.category"
	TargetTypePartAttachment  = "part.attachment"
	TargetTypeStorage         = "storage"
	TargetTypeStorageCategory = "storage.category"
	TargetTypeStorageImage    = "storage.image"
	TargetTypeUnknown         = "unknown" // Unsupported or not yet implemented link types
)

//Link contains the URL for part-lookup (Table: mate_links)
type Link struct {
	Link              string    `db:"link"`
	PartID            *int      `db:"partID"`
	PartCategoryID    *int      `db:"partCategoryID"`
	PartAttachmentID  *int      `db:"partAttachmentID"`
	StorageID         *int      `db:"storageID"`
	StorageCategoryID *int      `db:"storageCategoryID"`
	StorageImageID    *int      `db:"storageImageID"`
	AutoGenerated     bool      `db:"auto_generated"`
	CreatedAt         time.Time `db:"createdAt"`
}

// GetTargetType returns the target type string matching for this link
func (l *Link) GetTargetType() string {
	switch {
	case l.PartID != nil:
		return TargetTypePart
	case l.PartCategoryID != nil:
		return TargetTypePartCategory
	case l.PartAttachmentID != nil:
		return TargetTypePartAttachment
	case l.StorageID != nil:
		return TargetTypeStorage
	case l.StorageCategoryID != nil:
		return TargetTypeStorageCategory
	case l.StorageImageID != nil:
		return TargetTypeStorageImage
	}
	return TargetTypeUnknown
}

// ToDTO converts the link database model into its DTO representation
func (l *Link) ToDTO() LinkDTO {
	return LinkDTO{
		Link:          l.Link,
		TargetType:    l.GetTargetType(),
		Target:        "", // Our output does not provide the target (would be self-referencing)
		AutoGenerated: l.AutoGenerated,
		CreatedAt:     l.CreatedAt,
	}
}

type LinkRetrievalFn func(string) (*Link, error)

type LinkDTO struct {
	// Link ID
	Link string `json:"link"`
	// Type of entity we are targeting (currently only "part")
	TargetType string `json:"targetType"`
	// ID of the target to link to - this has to be another link ID since we do not disclose the internal IDs of
	// entities.
	// When searching, links will be auto-generated for every single result (if no link exists)
	Target string `json:"target,omitempty"`
	// Was the link auto-generated?
	AutoGenerated bool `json:"autoGenerated"`
	// When was the link created?
	CreatedAt time.Time `json:"createdAt,omitempty"`
}

// ToLink converts the link data transfer object to its database model
func (l *LinkDTO) ToLink(fn LinkRetrievalFn) (*Link, error) {
	out := Link{
		Link:          strings.TrimSpace(l.Link),
		AutoGenerated: l.AutoGenerated,
	}
	// Get the link to determine the internal part ID
	link, err := fn(strings.TrimSpace(l.Target))
	if err != nil {
		return nil, fmt.Errorf("failed to fetch target: %w", err)
	}
	if link == nil {
		return nil, fmt.Errorf("illegal target %#v", l.Target)
	}
	var checkVal *int
	switch l.TargetType {
	case TargetTypePart:
		checkVal = link.PartID
		out.PartID = link.PartID
	case TargetTypePartCategory:
		checkVal = link.PartCategoryID
		out.PartCategoryID = link.PartCategoryID
	case TargetTypePartAttachment:
		checkVal = link.PartAttachmentID
		out.PartAttachmentID = link.PartAttachmentID
	case TargetTypeStorage:
		checkVal = link.StorageID
		out.StorageID = link.StorageID
	case TargetTypeStorageCategory:
		checkVal = link.StorageCategoryID
		out.StorageCategoryID = link.StorageCategoryID
	case TargetTypeStorageImage:
		checkVal = link.StorageImageID
		out.StorageImageID = link.StorageImageID
	default:
		return nil, fmt.Errorf("unknown target type %#v", l.TargetType)
	}
	if checkVal == nil || *checkVal <= 0 {
		return nil, fmt.Errorf("wrong target type for %#v or illegal target", l.Target)
	}
	return &out, nil
}

// Validate checks the DTO if all properties are set correctly
func (l *LinkDTO) Validate() error {
	if strings.TrimSpace(l.Link) == "" {
		return fmt.Errorf("link is empty")
	}
	switch l.TargetType {
	case TargetTypePart,
		TargetTypePartCategory,
		TargetTypePartAttachment,
		TargetTypeStorage,
		TargetTypeStorageCategory,
		TargetTypeStorageImage:
		if strings.TrimSpace(l.Target) == "" {
			return fmt.Errorf("target is empty")
		}
	default:
		return fmt.Errorf("unknown target type %#v", l.TargetType)
	}
	return nil
}
